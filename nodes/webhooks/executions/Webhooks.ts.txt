import {
	IDataObject,
	INodeExecutionData,
	IWebhookFunctions,
	IWebhookResponseData,
} from 'n8n-workflow';
import { setupOutputConnection } from '../utils/webhookUtils';
// import { rm, } from 'fs/promises';
import type * as express from 'express';

export interface IPaymentPayload {
	x402Version: number;
	scheme: string;
	network: string;
	payload: {
		authorization: {
			from: string;
			to: string;
			value: string;
			validAfter: string;
			validBefore: string;
			nonce: string;
		};
		signature: string;
	};
}

export interface IPaymentRequirements {
	scheme: string;
	network: string;
	maxAmountRequired: string; // BigNumberString
	resource: string;
	description: string;
	mimeType: string;
	outputSchema: any;
	payTo: string; // EVM Account Address
	maxTimeoutSeconds: number;
	asset: string; // EVM Contract Address
	extra: {
		name: string;
		version: string;
	};
}


export async function webhookTrigger(this: IWebhookFunctions): Promise<IWebhookResponseData> {
	const webhookType = this.getNodeParameter('webhookType') as string;
	const body = this.getBodyData();

	if (webhookType === 'x402') {
		return await handleX402Webhook.call(this, body);
	} else {
		throw new Error(`Unsupported webhook type: ${webhookType}`);
	}
}

async function handleX402Webhook(
	this: IWebhookFunctions,
	_body: IDataObject,
): Promise<IWebhookResponseData> {
	const responseMode = this.getNodeParameter('responseMode', 'onReceived') as string;

	const headers = this.getHeaderData();
	const req = this.getRequestObject();
	const resp = this.getResponseObject();
	const requestMethod = this.getRequestObject().method;

	const prepareOutput = setupOutputConnection(this, requestMethod, {
		// jwtPayload: validationData,
	});

	// Get the credential data (always available since it's required at node level)
	const credentials = await this.getCredentials('crossmintApi');
	if (!credentials) {
		// This is an example of direct response with Express
		resp.writeHead(403);
		resp.end('crossmintApi credential not found');
		return { noWebhookResponse: true };
	}

	// Coinbase credentials (apiKeyId/apiKeySecret) are required for x402 processing
	const coinbaseKeyId = (credentials as any).apiKeyId as string | undefined;
	const coinbaseKeySecret = (credentials as any).apiKeySecret as string | undefined;
	if (!coinbaseKeyId || !coinbaseKeySecret) {
		resp.writeHead(403);
		resp.end('crossmintApi credential missing Coinbase apiKeyId or apiKeySecret');
		return { noWebhookResponse: true };
	}

	// TODO: Extract this out of file
	const supportedTokens = {
		kinds: [
			{
				scheme: 'eip3009',
				network: 'solana',
				tokens: [
					{
						name: 'USDC',
						contractAddress: 'usdc',
						version: '1',
					},
					{
						name: 'SOL',
						contractAddress: 'sol',
						version: '1',
					},
				],
			},
		],
	};

	// We need to figure out which of the tokens have been configured for this node
	const configuredTokens = this.getNodeParameter('tokens') as {
		paymentToken: { paymentToken: string; payToAddress: string; paymentAmount: number }[];
	};

	const resourceDescription = ''; // By default (No options in node)
	const mimeType = 'application/json'; // By default (No options in node)

	const responseData = this.getNodeParameter('responseData') as string;

	const webhookUrl = this.getNodeWebhookUrl('default');
	if (webhookUrl == null) {
		resp.writeHead(403);
		resp.end('webhookUrl not found');
		return { noWebhookResponse: true };
	}

	// We are going to loop over the configured tokens- only those are the supported ones.
	const paymentRequirements = new Array<PaymentRequirements>();
	const configuredKinds = new Array<string>();

	for (const configuredToken of configuredTokens.paymentToken) {
		// Find the supported token that matches the configured token
		// We need to split up the paymentToken string into the network and contract address.
		const [network, contractAddress] = configuredToken.paymentToken.split(':');

		// If the kind already has a configuration, that's an error- you can only configure one token per network.
		if (configuredKinds.includes(network)) {
			resp.writeHead(403);
			resp.end(
				`Misconfiguration: Network ${network} has multiple configured tokens. You may only have one payment token per network.`,
			);
			return { noWebhookResponse: true };
		}
		configuredKinds.push(network);

		// First we find the "kind" that matches the network.
		const kind = supportedTokens.kinds.find((kind) => kind.network === network);
		if (kind == null) {
			throw new Error(`Supported network ${network} not found`);
		}

		// Now we find the token that matches the contract address.
		const supportedToken = kind.tokens.find((token) => token.contractAddress === contractAddress);
		if (supportedToken == null) {
			throw new Error(`Supported token ${contractAddress} not found`);
		}

		// Now we create the payment config.
		paymentRequirements.push(
			new PaymentRequirements(
				kind.scheme,
				kind.network,
				configuredToken.paymentAmount.toString(),
				webhookUrl,
				resourceDescription,
				mimeType,
				{},
				configuredToken.payToAddress,
				60,
				supportedToken.contractAddress,
				{
					name: supportedToken.name,
					version: supportedToken.version,
				},
			),
		);
	}

	// If there's no x-payment header, return a 402 error with payment details
	const xPaymentHeader = headers['x-payment'];
	if (!xPaymentHeader == null || typeof xPaymentHeader !== 'string') {
		return generateX402Error(resp, 'No x-payment header provided', paymentRequirements);
	}

	// try to decode the x-payment header if it exists
	try {
		// Decode the x-payment header from base64
		const decodedXPayment = Buffer.from(xPaymentHeader, 'base64').toString('utf-8');

		// Parse the decoded value into a JSON object
		const decodedXPaymentJson = JSON.parse(decodedXPayment) as IPaymentPayload;

		const validation = validateXPayment(decodedXPaymentJson);
		if (validation != 'valid') {
			resp.writeHead(402, { 'Content-Type': 'application/json' });
			resp.end(
				JSON.stringify({
					error: {
						errorMessage: 'x-payment header is not valid',
						paymentConfigs: paymentRequirements,
					},
				}),
			);
			return { noWebhookResponse: true };
		}

		const verification = verifyPaymentDetails(decodedXPaymentJson, paymentRequirements);
		if (!verification.valid) {
			return generateX402Error(
				resp,
				`x-payment header is not valid for reasons: ${verification.errors}`,
				paymentRequirements,
			);
		}

		// Looks like everything is valid, now we'll verify the payment via Crossmint API.
		// We need to get the actual payment config- there's only one per network.
		// Problem with the x402 spec is that they don't send the actual token address.
		// So we need to find the config that matches the network, there should be only 1,
		// and we use that.

		// TODO: Replace with Crossmint API call
		// const verifyResponse = await verifyX402Payment(
		// 	this,
		// 	decodedXPaymentJson.x402Version,
		// 	decodedXPaymentJson,
		// 	verification.paymentRequirements!,
		// );
		const verifyResponse = { isValid: true, invalidReason: '' };

		if (!verifyResponse.isValid) {
			return generateX402Error(
				resp,
				`x-payment verification failed: ${verifyResponse.invalidReason}`,
				paymentRequirements,
			);
		}

		// If the verification is valid, we are going to be a little optimistic about the settlement. Since this can take a while, if the method errors,
		// (such as from a Cloudflare 502), we'll move on and assume it's successful.

		try {
			// Payment is verified, now we need to settle it!
			// TODO: Replace with Crossmint API call
			// const settleResponse = await settleX402Payment(
			// 	this,
			// 	decodedXPaymentJson.x402Version,
			// 	decodedXPaymentJson,
			// 	verification.paymentRequirements!,
			// );
			const settleResponse = { success: true, txHash: 'MOCK_TX_HASH_PLACEHOLDER', error: '' };

			if (!settleResponse.success) {
				resp.writeHead(402, { 'Content-Type': 'application/json' });
				resp.end(
					JSON.stringify({
						error: {
							errorMessage: `x-payment settlement failed: ${settleResponse.error}`,
						},
					}),
				);
				return { noWebhookResponse: true };
			}

			// Payment is settled, now we need to return the workflow data
			return generateResponse(
				this,
				req,
				responseMode,
				responseData,
				settleResponse.txHash,
				prepareOutput,
			);
		} catch (error) {
			this.logger.error('Error in x402 webhook settlement, moving on...', error);
			return generateResponse(this, req, responseMode, responseData, 'TBD', prepareOutput);
		}
	} catch (error) {
		this.logger.error('Error in x402 webhook', error);
		// Return an error object if the token format is invalid
		return generateX402Error(
			resp,
			`No x-payment header provided: ${error.message}`,
			paymentRequirements,
		);
	}
}

function generateResponse(
	context: IWebhookFunctions,
	req: express.Request,
	responseMode: string,
	responseData: string,
	txHash: string,
	prepareOutput: (data: INodeExecutionData) => INodeExecutionData[][],
) {
	const response: INodeExecutionData = {
		json: {
			headers: req.headers,
			params: req.params,
			query: req.query,
			body: req.body,
			txHash: txHash,
		},
	};
	if (responseMode === 'streaming') {
		const res = context.getResponseObject();

		// Set up streaming response headers
		res.writeHead(200, {
			'Content-Type': 'application/json; charset=utf-8',
			'Transfer-Encoding': 'chunked',
			'Cache-Control': 'no-cache',
			Connection: 'keep-alive',
		});

		// Flush headers immediately
		res.flushHeaders();

		return {
			noWebhookResponse: true,
			workflowData: prepareOutput(response),
		};
	}

	return {
		webhookResponse: responseData,
		workflowData: prepareOutput(response),
	};
}

function generateX402Error(
	resp: express.Response,
	errorMessage: string,
	paymentRequirements: IPaymentRequirements[],
): IWebhookResponseData {
	resp.writeHead(402, { 'Content-Type': 'application/json' });
	resp.end(
		JSON.stringify({
			error: {
				errorMessage,
				paymentConfigs: paymentRequirements,
			},
		}),
	);
	return { noWebhookResponse: true };
}

// ED-25519 signature verification
/*async function verify1ShotSignature(
	publicKey: string,
	signature: string,
	payload: any,
): Promise<boolean> {
	try {
		// Convert the public key from base64 to bytes
		const publicKeyBytes = Buffer.from(publicKey, 'base64');

		// Convert the signature from base64 to bytes
		const signatureBytes = Buffer.from(signature, 'base64');

		// Sort all object keys recursively and create a canonical JSON string
		const sortedData = sortObjectKeys(payload);
		const message = JSON.stringify(sortedData);

		// Convert the message to UTF-8 bytes
		const messageBytes = new TextEncoder().encode(message);

		// Verify the signature
		return await verifyAsync(signatureBytes, messageBytes, publicKeyBytes);
	} catch (error) {
		// If any error occurs during validation, return false
		return false;
	}
}*/

/**
 * Recursively sorts object keys alphabetically
 * @param obj - The object to sort
 * @returns A new object with sorted keys
 */
/*function sortObjectKeys(obj: Record<string, any>): Record<string, any> {
	if (obj === null || typeof obj !== 'object') {
		return obj;
	}

	if (Array.isArray(obj)) {
		return obj.map(sortObjectKeys);
	}

	return Object.keys(obj)
		.sort()
		.reduce((result: Record<string, any>, key: string) => {
			result[key] = sortObjectKeys(obj[key]);
			return result;
		}, {});
}*/

// this will make sure our x-payment header contains all necessary components
function validateXPayment(payment: IPaymentPayload): string {
	// Define the expected structure and types
	const requiredShape = {
		x402Version: 'number',
		scheme: 'string',
		network: 'string',
		payload: {
			authorization: {
				from: 'string',
				to: 'string',
				value: 'string',
				validAfter: 'string',
				validBefore: 'string',
				nonce: 'string',
			},
			signature: 'string',
		},
	};

	const missing = checkShape(requiredShape, payment, '');

	if (missing.length > 0) {
		return missing.join('; ');
	}
	return 'valid';
}

function checkShape(
	expected: Record<string, any>,
	actual: Record<string, any>,
	path: string,
): string[] {
	const missing = new Array<string>();
	for (const key in expected) {
		const currentPath = path ? path + '.' + key : key;

		if (!(key in actual)) {
			missing.push('Missing field: ' + currentPath);
		} else if (typeof expected[key] === 'object') {
			if (typeof actual[key] !== 'object' || actual[key] === null) {
				missing.push('Invalid type at ' + currentPath + ': expected object');
			} else {
				checkShape(expected[key], actual[key], currentPath);
			}
		} else {
			if (typeof actual[key] !== expected[key]) {
				missing.push(
					'Invalid type at ' +
						currentPath +
						': expected ' +
						expected[key] +
						', got ' +
						typeof actual[key],
				);
			}
		}
	}
	return missing;
}

// this function will ensure the x-payment header is for one of our supported
// networks, is for the correct amount, and pays the right address
function verifyPaymentDetails(
	header: IPaymentPayload,
	paymentRequirements: PaymentRequirements[],
): { valid: boolean; errors: string; paymentRequirements: PaymentRequirements | undefined } {
	const errors = [];

	// 1. Check that network exists in config
	const network = header.network;
	const configEntry = paymentRequirements.find(
		(pc) => pc.network.toLowerCase() == (network || '').toLowerCase(),
	);

	if (configEntry == null) {
		errors.push('Invalid or unsupported network: ' + network);
	}

	// 2. Check value >= maxAmountRequired
	if (configEntry) {
		try {
			const required = BigInt(configEntry.maxAmountRequired);
			let actual;

			actual = BigInt(header.payload.authorization.value);
			if (typeof actual !== 'undefined' && actual < required) {
				errors.push(`Value too low: got ${actual}, requires at least ${required}`);
			}
		} catch (e) {
			errors.push('Invalid value: must be numeric string');
		}

		// 3. Check 'to' matches payTo (case-insensitive)
		const toAddr = header.payload?.authorization?.to;
		if (toAddr == null) {
			errors.push("Missing 'to' field in authorization");
		} else if (toAddr.toLowerCase() != configEntry.payTo.toLowerCase()) {
			errors.push(`Invalid 'to' address: expected ${configEntry.payTo}, got ${toAddr}`);
		}

		// 4. Check the validBefore and validAfer timestamps.
		const now = Math.floor(Date.now() / 1000);
		try {
			const validAfter = Number(header.payload.authorization.validAfter);
			const validBefore = Number(header.payload.authorization.validBefore);

			if (validAfter > now) {
				errors.push(
					`Payment has not activated, validAfter is ${validAfter} but the server time is ${now}`,
				);
			}
			if (validBefore < now) {
				errors.push(
					`Payment has expired, validBefore is ${validBefore} but the server time is ${now}`,
				);
			}
		} catch (e) {
			errors.push(`Invalid validAfter or validBefore timestamps`);
		}
	}

	return {
		valid: errors.length == 0,
		errors: errors.join('; '),
		paymentRequirements: configEntry,
	};
}

class PaymentRequirements implements IPaymentRequirements {
	public constructor(
		public scheme: string,
		public network: string,
		public maxAmountRequired: string,
		public resource: string,
		public description: string,
		public mimeType: string,
		public outputSchema: any,
		public payTo: string,
		public maxTimeoutSeconds: number,
		public asset: string,
		public extra: {
			name: string;
			version: string;
		},
	) {}
}
